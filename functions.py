"""
functions.py

This script contains functions which will be used for our main process.

The description of each function is provided before its declaration.
In-line comments will explain each individual step.

The list of functions are as follows:

-   crop_img                Params: Saccadic Path Plot
-   format_list             Params: List of Corners
-   remove_outliers         Params: Saccadic Path Corners, World View Corners, Euclidean distance threshold
-   eucl_sort               Params: List of Corners
-   sim_anneal_sort         Params: List of Corners
"""

import cv2
import numpy as np
import csv
import random
import matplotlib.pyplot as plt
import math
import copy
from scipy.spatial import distance as dst


# INPUT:    Directory of files
# RETURNS:  Images of Saccadic Path, World View, and Guide Points
def get_images(folder):
    # read data from .csv generated by Pupil Labs
    data = csv.reader(open(folder + 'gaze_positions.csv'))

    # initialising counter & arrays for storing points
    i = 0
    px = []
    py = []

    # the .csv files generated have a fixed format
    # extracting relevant data
    for row in data:
        if i != 0:
            px.append(float(row[3]))  # row index [3] stores X coordinates
            py.append(float(row[4]))  # row index [4] stores Y coordinates
        i += 1

    # plotting the data points to get the shape drawn by the user
    # NOTE: plot is needed to be saved as image, as process will be raster
    _, plot = plt.subplots()
    plot.plot(px, py, '-o', ms=0, lw=1, alpha=1, color='black')
    plt.axis('off')
    plt.gca().set_aspect('equal', adjustable='box')
    plt.savefig(folder+'saccPath.png')

    # obtain world view & saccadic path

    # imported as colour image... any whitespace from graph plot is cropped out
    sacc_path = crop_img(cv2.imread(folder+'saccPath.png', 1))
    world_view = cv2.imread(folder + 'im.png', 0)  # world view is converted to grayscale

    # resizing world view image to dimensions of saccadic path
    y, x = sacc_path.shape
    world_view = cv2.resize(world_view, (x, y))

    return sacc_path, world_view


# INPUT:    Plot of the Saccadic Path
# RETURNS:  input image, with unnecessary whitespace removed
def crop_img(img):

    # convert img to grayscale
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # apply threshold
    _, thresh_gray = cv2.threshold(gray, thresh=100, maxval=255, type=cv2.THRESH_BINARY)

    points = np.argwhere(thresh_gray == 0)       # detect the black pixels (i.e. the edges)
    points = np.fliplr(points)                   # the edges are stored as coordinates, in points
    x, y, w, h = cv2.boundingRect(points)        # using the furthest points, create the rectangle
    x, y, w, h = x - 10, y - 10, w + 20, h + 20  # leaving some slight whitespace
    crop = gray[y:y + h, x:x + w]                # cropping the unnecessary parts

    return crop


# INPUT:    List of Harris feature points
# RETURNS:  List of Harris corners formatted for processing
def format_list(corner_list):
    new_list = []
    for i in corner_list:
        # each point is parsed as an integer
        new_list.append((int(i[0]), int(i[1])))
    return new_list


# INPUT:    Saccadic Path points, World View Points, and Euclidean distance threshold
# RETURNS:  The Saccadic Path points which are within the Euclidean distance threshold
def remove_outliers(list_1, list_2, max_dist):
    new_list = []                               # The new list
    for i in list_1:                            # iterate for list_1
        x = False                               # Intermediary boolean value, True if i is close to any pt in list_2
        for j in list_2:                        # iterate for second list
            if dst.euclidean(i, j) < max_dist:  # If current point of list_1 is close to a pt in list_2
                x = True                        # set x to True
        if x:                                   # If x is True
            new_list.append(i)                  # Append value to list to return
    return new_list                             # ...


# INPUT:    List of Corners
# RETURNS:  Same list, by using Closest Euclidean Distance to solve TSP (Greedy Search)
def eucl_sort(list_1):
    if len(list_1) > 1:
        distances = []
        paths = []

        for i in range(0, len(list_1)):         # attempting to start from all paths
            tmp_list = copy.copy(list_1)        # Our list is set as a temporary list to prevent overwriting
            new_list = list()                   # create the new list
            if tmp_list:
                new_list.append(tmp_list[i])    # Append the first element in list to new list
                tmp_list.remove(tmp_list[i])    # And Remove it from our temporary list
                while tmp_list:                 # while temporary list is not empty
                    # get the closest euclidean distance point to the last point in the new list
                    near = min(tmp_list, key=lambda x: dst.euclidean(new_list[-1], x))
                    new_list.append(near)       # append it to the new list
                    tmp_list.remove(near)       # and remove it from our temporary list
            paths.append(new_list)              # append path to list of paths

            # compute distance of current path
            distance = 0
            for j in range(1, len(new_list)):
                distance += dst.euclidean(new_list[j-1], new_list[j])
            distances.append(distance)

        # return shortest path found
        return paths[distances.index(min(distances))]
    # do nothing for cases where we have less than 2 points
    else:
        return list_1


# INPUT:    List of corners
# RETURNS:  Same list, by using Simulated Annealing to solve TSP
def sim_anneal_sort(list_1):
    n = len(list_1)

    # generate a random path
    path = random.sample(range(n), n)

    # for each iteration of temperature, spaced evenly on log space
    for temp in np.logspace(0, 5, num=10000)[::-1]:

        # randomly swap two positions
        [i, j] = sorted(random.sample(range(n), 2))
        new_path = path[:i] + path[j:j+1] + path[i+1:j] + path[i:i+1] + path[j+1:]

        # calculate the distances of both the old path and the new path
        old_d = sum([math.sqrt(sum([(list_1[path[(k+1) % n]][d]-list_1[path[k % n]][d])**2 for d in [0, 1]]))
                     for k in [j, j - 1, i, i - 1]])
        new_d = sum([math.sqrt(sum([(list_1[new_path[(k+1) % n]][d]-list_1[new_path[k % n]][d])**2 for d in [0, 1]]))
                     for k in [j, j - 1, i, i - 1]])

        # if Boltzmann-Gibbs condition is satisfied for any random number, utilise the new path
        if math.exp((old_d - new_d) / temp) > random.random():
            path = copy.copy(new_path)

    # return the list sorted by the order of the path
    return [list_1[path[i % n]] for i in range(n+1)]
